import * as fs from "fs-extra";
import * as path from "path";

const isCI = process.env.CI === "true";
if (isCI) {
  console.log("ðŸƒ CI detected, skipping .env.local generation");
  process.exit(0);
}

console.log("ðŸ”¥ Generating .env.local files");

const autogeneratedComment =
  "# This file is autogenerated. To make changes, modify the root level .env.local file and run bun install\n";

// Read the .env file
const envFilePath = path.join(__dirname, "..", "..", ".env.gen");
if (!fs.existsSync(envFilePath)) {
  console.log("ðŸ›‘ .env.local file does not exist");
  process.exit(0);
}
const envFileContent = fs.readFileSync(envFilePath, "utf8");

/**
 * Generate Next.js .env file content
 */
const nextOutputPath = path.join(
  __dirname,
  "..",
  "..",
  ".env.local",
);
const nextFileContent = envFileContent
  .split("\n")
  .map((line: string) => {
    if (line.startsWith("PUBLIC_")) {
      return line.replace(/^PUBLIC_/, "NEXT_PUBLIC_");
    }
  })
  .filter((line: string) => !!line)
  .join("\n");
fs.writeFileSync(nextOutputPath, `${autogeneratedComment}\n${nextFileContent}`);

/**
 * Generate Cloudflare Wrangler .dev.vars file content
 */
const wranglerOutputPath = path.join(
  __dirname,
  "..",
  "..",
  "packages",
  "api",
  ".dev.vars",
);
// Remove public variables from output
const wranglerFileContent = envFileContent
  .split("\n")
  .map((line: string) => {
    if (line.startsWith("#")) return;

    if (line.startsWith("PUBLIC_APP_URL"))
      return line.replace(/^PUBLIC_APP_URL/, "APP_URL");
    if (!line.startsWith("PUBLIC_")) {
      return line;
    }
  })
  .filter((line: string) => !!line)
  .join("\n");
const noD1Warning = "NO_D1_WARNING=true";
fs.writeFileSync(
  wranglerOutputPath,
  `${autogeneratedComment}\n${wranglerFileContent}\n${noD1Warning}`,
);
